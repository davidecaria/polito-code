/*
Analyze the following segment of code. Indicate which are the possible outputs generated by the
program when 5 is passed as an argument. Note that incorrect answers imply a penalty in the final
score.
#define N 100
int main (int argc, char *argv[]) {
    int n;
    char str[N];
    n = atoi (argv[1]);
    setbuf(stdout,0);
    if (n>0 && !fork()) {
        if (!fork()) {
            fprintf (stdout, "E");
            sprintf (str, "%d", n-1);
            execlp (argv[0], argv[0], str, NULL);
        } else {
            sprintf (str, "echo -n S");
            system (str);
        }
    }
    return 1;
}

Select one or more alternatives
1. SESESESESE
2. ESESESESES
3. SSSEEESESE
4. SESESESESESESESESESE
5. SE
6. ES

*/

/*
Solution:

Let us analyze the first iteration of the program:

The parameter passed is 5 so n=5. The outer most if statement generates a child C1 that executes the code inside.
The father does not execute anything and terminates with a return 1. The the child C1 performes another fork and 
generates C1_1 that execute the code inside the if, while the father C1 executes the code inside the else.

The father C1 prints "S" on screen and terminates with a return 1
The child C1_1 executes again the original program but with n-1 parameter => 4

The graph of a single iteration is the following:

        P
        |
        |
       / \
      /   \
    P      C1
            |
            |
           / \
          /   \
         C1    C1_1

From now on the C1_1 becomes the P and the cycle repetes untile n=0 where the contion on the outer loop fails

The possibile outputs are:
1. SESESESESE
2. ESESESESES
The may depend on wheather the father or the child prints first so they are okay

Wrong results:
3. SSSEEESESE
4. SESESESESESESESESESE
5. SE
6. ES

5 and 6 do not make sense since we have to repete 5 times the tree
4 is too long for the iteration that we have 
3 is wrong since we can't have many S consecutive and many E consecutive, this is because the basic block that is printed is either SE or ES
*/