/*
A binary number of size n can be easily generated by a recursive function
like the one reported in file e05recursive.c

Transform the recursive program into a concurrent one, replacing the
recursive procedure with the generation of an appropriate number of
*processes*.
Each process must display one binary number.
Binary numbers can be displayed in any order.

For example, if n=3, the function must generate and print numbers:
000, 001, 010, 011, 100, 101, 110, 111
IN ANY ORDER.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>
#include <sys/wait.h>

int *fromDecimalToInteger(int dec, int n);
int **vet;

int main(int argc, char *argv[]){

    if(argc != 2){
        printf("Error!\n");
        return -1;
    }

    int n;
    int i;
    int bin;
    int status;

    n = atoi (argv[1]);

    double numberOfProcesses = pow((double)2,(double)n);

    vet = (int **)malloc(numberOfProcesses * sizeof(int *));
    if (vet == NULL) {
        printf("Allocatin Error.\n");
        exit(1);
    }
    /*
    for(int i=0;i<numberOfProcesses;i++){
        vet[i] = (int *)malloc(n*sizeof(int));
        if(vet[i]==NULL){
            printf("Allocation Error\n");
            exit(1);
        }
    }
    */

    __pid_t pid;


    for(i=0;i<numberOfProcesses;i++){
        pid=fork();
        if(pid==0){
            break;
        }
        //printf("%d\n",pid);
    }
    
    if(pid==0){
        vet[i] = fromDecimalToInteger(i,n);
        for(int j=0;j<n;j++){
            printf("%d",vet[i][j]);
        }
        printf("\n");
        
    }

    return 0;
}

int *fromDecimalToInteger(int dec, int n){

    int *outPut;
    outPut = (int *)malloc(n*sizeof(int));

    int index = dec;
    for(int i=0;dec>0;i++){
        outPut[i]=dec%2;
        dec=dec/2;
    }
    return outPut;
}